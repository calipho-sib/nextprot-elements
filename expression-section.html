<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="evidence-item.html">
<link rel="import" href="quality-label.html">
<link rel="import" href="external-scripts.html">
<link rel="import" href="nextprot-elements-shared-styles.html">
<link rel="import" href="heatmap-table-item.html">

<!--
`expression-section`
Annotation section used in function, medical, and expression views.

#### Example
    <generic-annotation-section section="function" categories='[ "GENERAL-ANNOTATION" ]'></generic-annotation-section>
@demo demo/expression-section-demo.html
-->
<dom-module id="expression-section">
    <template>
        <style include="nextprot-elements-shared-styles">
            :host {
                display: block;
                min-width: 700px;
                margin: 20px;
            }
        </style>

        <div class="pull-right">
            <template is="dom-repeat" items="[[heatmapOptions.methods]]" as="method">
                <div class="style-scope heatmap-table-row" style="margin-right: 25px; display:inline-block">
                    <div class="dropdown">
                        <button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu2" data-toggle="dropdown">
                            [[method.methodName]]
                            <span class="caret"></span>
                        </button>
                        <ul class="dropdown-menu" aria-labelledby="dropdownMenu2">
                            <li><a href="#" style="padding-top: 0px; padding-bottom: 0px"><span class="glyphicon glyphicon-remove pull-right"></span></a></li>
                            <template is="dom-repeat" items="[[method.possibleValues]]" as="value">
                                <li><a href="#" style$="{{_computeStyle(value.color)}}"><span class="glyphicon glyphicon-ok"></span>&nbsp;[[value.name]]</a></li>
                            </template>
                        </ul>
                    </div>
                </div>
            </template>
        </div>


        <ul class="nav nav-tabs" role="tablist">
            <li id="ontology-tab" class="active">
                <a href="#ontology-content" id="ontology-tab-content" role="tab" data-toggle="tab">Ontology</a>
            </li>
            <li id="flat-tab">
                <a href="#flat-content" id="flat-tab-content" role="tab" data-toggle="tab">Flat</a>
            </li>
        </ul>

        <div class="tab-content">
            <div id="ontology-content" role="tabpanel" aria-labelledby="ontology-tab" class="tab-pane active in">
                <heatmap-table-item data=[[heatmapFlatData]] options=[[heatmapOptions]]></heatmap-table-item>
            </div>
            <!--
                        <div id="flat-content" role="tabpanel" aria-labelledby="flat-tab" class="tab-pane fade">
                            <heatmap-table-item data=[[heatmapData]] options=[[heatmapOptions]]></heatmap-table-item>
                        </div>
                        -->
        </div>

    </template>

    <!-- Palettes: https://material.io/guidelines/style/color.html#color-color-palette-->

    <script>
        Polymer({
            is: 'expression-section',
            properties: {
                nxConfig: {
                    type: Object,
                    value: {}
                },
                isTree: {
                    type: Boolean,
                    value: true
                },
                expressionProfileData: {
                    type: Object,
                    value: {}
                },
                heatmapFlatData: {
                    type: Array,
                    value: []
                },
                heatmapData: {
                    type: Array,
                    value: []
                },
                heatmapOptions: {
                    type: Object,
                    value: { "methods" : [
                        {methodName : "MicroArray", methodEvidenceCodeName: "microarray evidence", possibleValues : [{name : "Positive", color: "#9575CD"}, {name : "Not detected", color : "#EDE7F6"}]},
                        {methodName : "EST", methodEvidenceCodeName: "transcript expression evidence", possibleValues : [{name: "Positive", color: "#9FA8DA"}]},
                        {methodName : "IHC", methodEvidenceCodeName: "immunolocalization evidence", possibleValues : [{name: "High", color: "#42A5F5"}, {name: "Medium", color: "#90CAF9"}, {name: "Low", color: "#BBDEFB"}, {name: "Not detected", color: "#E3F2FD"}]}]}
                },
                section: {
                    type: String
                },
                goldOnly: {
                    type: Boolean,
                    observer: "_getAnnotationsByView"
                },
                count: {
                    type: Number,
                    notify: true
                },
                isoform: {
                    type: String,
                    observer: "_reloadIsoform"
                }
            },
            ready: function () {
                this.isTree = true;
                //if(this.evidencesShown===undefined) this._toggleAllEvidences();
                Polymer.RenderStatus.afterNextRender(this, function () {
                    var nx = new Nextprot.Client("neXtprot expression section", "Calipho Group");
                    if (this.nxConfig.env) nx.updateEnvironment(this.nxConfig.env);

                    //For development
                    nx.setApiBaseUrl("http://localhost:8080/components/nextprot-elements/mock-api-data")

                    var apiCall = [];
                    apiCall.push(nx.getTerminologyByName("nextprot-anatomy-cv"));
                    apiCall.push(nx.getAnnotationsByCategory(this.nxConfig.entry, "expression-profile"));

                    var self = this;
                    Promise.all(apiCall).then(function (result) {
                        var nxAnatomy = result[0];
                        self.expressionProfileData = result[1];
                        self.heatmapFlatData = self._convertNextProtDataIntoHeatMapTableFormat(null, self.expressionProfileData)
                        //self.heatmapData = self._convertNextProtDataIntoHeatMapTableFormat(nxAnatomy, self.expressionProfileData).substring(0, 4);

                    }).catch(function (err) {
                        // catch any error that happened so far
                        console.log("Argh, broken: " + err.message);
                        console.log("Error at line : " + err.stack);
                        self.$.spinner.removeAttribute('active');
                        self.count = 0;
                    });

                });
            },
            _isSilver: function (quality) {
                return quality === "SILVER"
            },
            _showHide: function (e) {
                var args = e.target.getAttribute('data-args')
                if (args == 'ontology') {
                    this.isTree = true;
                    this.$$('#ontology-tab').classList.add("active")
                    this.$$('#flat-tab').classList.remove("active")
                } else {
                    this.isTree = false;
                    this.$$('#flat-tab').classList.add("active")
                    this.$$('#ontology-tab').classList.remove("active")
                }
            },
            _computeStyle: function (value) {
                return "margin: 5px; background-color: " + value
            },
            _sortTermsAlphabetically: function (a, b) {
                if (a.cvTermName < b.cvTermName) return -1;
                if (a.cvTermName > b.cvTermName) return 1;
                return 0;
            },
            _defaultValues: function () {
                var result = [];
                for (var n = 0; n < 7; n++) {
                    result.push({ value: "", cssClass: "", evidences: [] });
                }
                return result;
            },
            _generateGroupedValuesForHeatMap: function(annotation, evidences, flat) {

                var groups = []
                var methods = [ {
                    methodName : "MicroArray", methodEvidenceCodeName: "microarray evidence",
                    possibleValues : [{expressionLevel : "positive", color: "#9575CD"},
                        {expressionLevel : "negative", color : "#EDE7F6"}]
                },
                    {
                        methodName : "EST", methodEvidenceCodeName: "transcript expression evidence",
                        possibleValues : [{expressionLevel: "positive", color: "#9FA8DA"}]
                    },
                    {   methodName : "IHC", methodEvidenceCodeName: "immunolocalization evidence",
                        possibleValues : [{expressionLevel: "high", color: "#42A5F5"},
                            {expressionLevel: "medium", color: "#90CAF9"},
                            {expressionLevel: "low", color: "#BBDEFB"},
                            {expressionLevel: "not detected", color: "#E3F2FD"}]
                    }]

                var atLeastOneEvidenceValid = false;

                methods.forEach(function (method) {
                    var methodPossibleValues = method.possibleValues;
                    var groupObject = {name: method.methodName, values: []}
                    groups.push(groupObject)
                    methodPossibleValues.forEach(function (methodPossibleValue) {

                        var evidenceMatchCount = 0;
                        for(var e=0; e<evidences.length; e++){
                            var evidence = evidences[e]
                            if (evidence.evidenceCodeName === method.methodEvidenceCodeName) {
                                if (evidence.expressionLevel === methodPossibleValue.expressionLevel) {
                                    evidenceMatchCount++;
                                    atLeastOneEvidenceValid = true;
                                }
                            }
                        }
                        groupObject.values.push({currentNodeEvidenceCount : evidenceMatchCount, color : methodPossibleValue.color})

                    })

                });

                if(!atLeastOneEvidenceValid){
                    console.log("Missing a valid value for annotation" , annotation.cvTermAccessionCode ,  "with evidences: " , evidences.length /*, "current values are ", values*/);
                    //alert("Missing a valid value for annotation " + annotation.cvTermAccessionCode + " with evidences: " + evidences.length /*, "current values are ", values*/)
                }
                return groups;

            },
            _renameMicroArrayEvidenceCode: function(data) {
                data.annot.forEach(function (annotation) {
                    annotation.evidences.forEach(function(evidence){
                        if(evidence.evidenceCodeName === "microarray RNA expression level evidence"){
                            evidence.evidenceCodeName = "microarray evidence"
                        }
                    })
                })
            },
            _enrichEvidenceWithResourceUrl: function(heatmapData, xrefs) {
                heatmapData.forEach(function(data){
                    data.annotation.evidences.forEach(function(evidence){

                        var resource = xrefs[evidence.resourceId]
                        evidence.url = resource.resolvedUrl.replace(/amp;/g, "")

                        //Define the URL label
                        if(evidence.properties["antibodies acc"]){
                            evidence.urlLabel = evidence.properties["antibodies acc"]
                        }else {

                            var geneId = evidence.resourceAccession.slice(evidence.resourceAccession.indexOf("gene_id=") + 8);
                            if (geneId.indexOf("&amp") !== -1) {
                                geneId = geneId.substring(0, geneId.indexOf("&amp"));
                            }
                            evidence.urlLabel = geneId;
                        }
                    })
                })

            },
            _enrichEvidenceObjectWithExperimentalContext: function(heatmapData, experimentalContext) {
                heatmapData.forEach(function(data){
                    data.annotation.evidences.forEach(function(evidence){

                        var context = experimentalContext[evidence.experimentalContextId]

                        var levelAndStageLabel = "";

                        if(evidence.negativeEvidence) {
                            levelAndStageLabel = "No expression detected"
                        } else {
                            if(evidence.expressionLevel === "low") {
                                levelAndStageLabel = "Low expression detected"
                            }else if(evidence.expressionLevel === "medium") {
                                levelAndStageLabel = "Medium expression detected"
                            }else if(evidence.expressionLevel === "high") {
                                levelAndStageLabel = "High expression detected"
                            }else { //Case of microarray for example
                                levelAndStageLabel = "Expression detected"
                            }
                        }

                        if(context.developmentalStage) {
                            var label = context.developmentalStage.name
                            levelAndStageLabel = levelAndStageLabel  + " at " + (label === "unknown" ? (label + " stage") : label) + "."
                        }else {
                            levelAndStageLabel += "."
                        }
                        evidence.levelAndStageLabel = levelAndStageLabel;

                    })
                })
            },
            _convertNextProtDataIntoHeatMapTableFormat: function (terminology, data) {


                var cvTermList = [];
                var heatmapData = [];
                var self = this;

                //According to specs the eco name is too long
                this._renameMicroArrayEvidenceCode(data);

                if(terminology){
                    cvTermList = terminology["cvTermList"]
                }else {
                    heatmapData = data.annot.map(function(a) {return {rowLabel : a.cvTermName,
                        linkLabel: a.cvTermAccessionCode,
                        linkURL :  "http://www.nextprot.org/db/term/" + a.cvTermAccessionCode,
                        annotation : a,
                        groupValues: self._generateGroupedValuesForHeatMap(a, a.evidences, true),
                        evidences: a.evidences}})
                }


                this._enrichEvidenceObjectWithExperimentalContext(heatmapData, data["contexts"])
                this._enrichEvidenceWithResourceUrl(heatmapData, data['xrefs'])

                // Sort alphabetically
                heatmapData = heatmapData.sort(function (a, b) {
                    if(a.rowLabel < b.rowLabel) return -1;
                    if(a.rowLabel > b.rowLabel) return 1;
                    return 0;
                })

                return heatmapData;

                /*
                 var termDict = {};
                 var queue = [];
                 var heatMapTableRoot = null;
                 var detailList = [];*/


                /*
                 for (var i = 0; i < cvTermList.length; i++) {
                 termDict[cvTermList[i].accession] = cvTermList[i];
                 if (cvTermList[i].ancestorAccession === null) {
                 var node = {};
                 node.ancestorIds = null;
                 node.children = [];
                 node.values = this._defaultValues();
                 node.detailData = [];
                 node.rowLabel = cvTermList[i].name;
                 node.id = cvTermList[i].accession;
                 node.linkLabel = "[" + cvTermList[i].accession + "]"
                 node.linkURL = "http://www.nextprot.org/db/term/" + cvTermList[i].accession;
                 heatMapTableRoot = node;
                 queue.push(heatMapTableRoot);
                 detailList.push(node.detailData);
                 }
                 }

                 while (queue.length !== 0) {
                 var currNode = queue.shift();
                 var currTerm = termDict[currNode.id];
                 if (currTerm && currTerm.childAccession) {
                 for (var i = 0; i < currTerm.childAccession.length; i++) {
                 var childTerm = termDict[currTerm.childAccession[i]];
                 var childNode = {};
                 childNode.ancestorIds = currNode;
                 childNode.children = [];
                 childNode.values = this._defaultValues();
                 childNode.detailData = [];
                 childNode.id = childTerm.accession;
                 childNode.rowLabel = childTerm.name;
                 childNode.linkLabel = "[" + childTerm.accession + "]"
                 childNode.linkURL = "http://www.nextprot.org/db/term/" + childTerm.accession;
                 queue.push(childNode);

                 currNode.children.push(childNode);

                 detailList.push(childNode.detailData);
                 }
                 }
                 }

                 function updateAncestorValues(data, values) {
                 for (var i = 0; i < data.values.length; i++) {
                 if (data.values[i].value === "" || data.values[i].value === undefined) {
                 data.values[i].value = values[i].value;
                 }
                 }
                 if (data.ancestorIds) {
                 updateAncestorValues(data.ancestorIds, values);
                 }
                 }

                 var codeNameToShortName = {
                 "microarray RNA expression level evidence": "Microarray",
                 "transcript expression evidence": "EST",
                 "immunolocalization evidence": "IHC"
                 }

                 function createDetailWithEvidence(evidence, value) {
                 var detail = {};
                 detail['evidenceCodeName'] = codeNameToShortName[evidence.evidenceCodeName];
                 detail['dbSource'] = evidence.resourceDb;
                 detail['value'] = value;
                 detail['ensemblLink'] = xrefDict[evidence.resourceId].resolvedUrl.replace(/amp;/g, "");

                 //setting ensembl
                 if (evidence.antibodies) {
                 detail['ensembl'] = evidence.antibodies;
                 } else {
                 detail['ensembl'] = evidence.resourceAccession.slice(evidence.resourceAccession.indexOf("gene_id=") + 8);
                 if (detail['ensembl'].indexOf("&amp") !== -1) {
                 detail['ensembl'] = detail['ensembl'].substring(0, detail['ensembl'].indexOf("&amp"));
                 }
                 }

                 if (evidence.qualityQualifier === "SILVER") {
                 detail['qualityQualifier'] = evidence.qualityQualifier;
                 }

                 if (experimentalContext[evidence.experimentalContextId]) {
                 if (evidence.expressionLevel === "negative") {
                 detail['description'] = "Expression not detected at " + experimentalContext[evidence.experimentalContextId];
                 } else {
                 detail['description'] = "Expression " + evidence.expressionLevel + " at " + experimentalContext[evidence.experimentalContextId];
                 }
                 } else {
                 if (evidence.expressionLevel === "negative") {
                 detail['description'] = "Expression not detected";
                 } else {
                 detail['description'] = "Expression " + evidence.expressionLevel
                 }
                 }
                 return detail;
                 }

                 function addAnnotToHeatMapTable(data, annot) {
                 //Data may equal to null when its root
                 if (data.id === annot.cvTermAccessionCode) {
                 for (var i = 0; i < annot.evidences.length; i++) {

                 var evidence = annot.evidences[i]; //There might be more than one evidence for each "statement", this should be reflected on the heatMapTable table as well
                 var detail = {};

                 if (evidence.evidenceCodeName === "microarray RNA expression level evidence" && evidence.expressionLevel === "positive") {
                 data.values[0]['value'] = evidence.expressionLevel;
                 data.values[0]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[0].value);
                 } else if ((evidence.evidenceCodeName === "microarray RNA expression level evidence" && evidence.expressionLevel === "not detected")
                 || (evidence.evidenceCodeName === "microarray RNA expression level evidence" && evidence.expressionLevel === "negative" && evidence.negativeEvidence === true)) {
                 data.values[1]['value'] = evidence.expressionLevel;
                 data.values[1]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[1].value);
                 } else if (evidence.evidenceCodeName === "transcript expression evidence" && evidence.expressionLevel === "positive") {
                 data.values[2]['value'] = evidence.expressionLevel;
                 data.values[2]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[2].value);
                 } else if (evidence.evidenceCodeName === "immunolocalization evidence" && evidence.expressionLevel === "high") {
                 data.values[3]['value'] = evidence.expressionLevel;
                 data.values[3]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[3].value);
                 } else if (evidence.evidenceCodeName === "immunolocalization evidence" && evidence.expressionLevel === "medium") {
                 data.values[4]['value'] = evidence.expressionLevel;
                 data.values[4]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[4].value);
                 } else if (evidence.evidenceCodeName === "immunolocalization evidence" && evidence.expressionLevel === "low") {
                 data.values[5]['value'] = evidence.expressionLevel;
                 data.values[5]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[5].value);
                 } else if (evidence.evidenceCodeName === "immunolocalization evidence" && evidence.expressionLevel === "not detected") {
                 data.values[6]['value'] = evidence.expressionLevel;
                 data.values[6]['evidences'].push(evidence);
                 detail = createDetailWithEvidence(evidence, data.values[6].value);
                 detail['description'] = "Expression not detected";
                 }

                 data.detailData.push(detail);
                 }

                 if (data.ancestorIds) {
                 updateAncestorValues(data.ancestorIds, data.values);
                 }
                 }

                 for (var i = 0; i < data.children.length; i++) {
                 addAnnotToHeatMapTable(data.children[i], annot);
                 }
                 }

                 for (var i = 0; i < data.annot.length; i++) {
                 var annot = data.annot[i];
                 addAnnotToHeatMapTable(heatMapTableRoot, annot);
                 }

                 var rowLabelsToheatMapTable = {
                 "Alimentary system": "alimentary-system",
                 "Cardiovascular system": "cardiovascular-system",
                 "Dermal system": "dermal-system",
                 "Endocrine system": "endocrine-system",
                 "Exocrine system": "exocrine-system",
                 "Hemolymphoid and immune system": "hemolymphoid-and-immune-system",
                 "Musculoskeletal system": "musculoskeletal-system",
                 "Nervous system": "nervous-system",
                 "Reproductive system": "reproductive-system",
                 "Respiratory system": "respiratory-system",
                 "Urinary system": "urinary-system",
                 "Sense organ": "sense-organ",
                 "Body part": "body-part",
                 "Tissue": "tissue",
                 "Cell type": "cell-type",
                 "Fluid and secretion": "fluid-and-secretion",
                 "Gestational structure": "gestational-structure"
                 }

                 var heatmapData = [];
                 function findHeatMapData(data, step) {
                 if (step > 2) return;
                 if (rowLabelsToheatMapTable[data.rowLabel]) {
                 heatmapData.push(data);
                 }
                 for (var i = 0; i < data.children.length; i++) {
                 findHeatMapData(data.children[i], step + 1);
                 }
                 }

                 findHeatMapData(heatMapTableRoot, 0);

                 heatmapData.sort(function (a, b) {
                 if (a.rowLabel.indexOf("system") !== -1 && b.rowLabel.indexOf("system") === -1) return -1;
                 if (a.rowLabel.indexOf("system") === -1 && b.rowLabel.indexOf("system") !== -1) return 1;
                 if (a.rowLabel < b.rowLabel) return -1;
                 if (a.rowLabel > b.rowLabel) return 1;
                 return 0;
                 });

                 function sortDetail(detailList) {
                 var levelPriorityDict = {
                 "High": 5,
                 "Medium": 4,
                 "Low": 3,
                 "Positive": 2,
                 "NotDetected": 1
                 }
                 var codePriorityDict = {
                 "Microarray": 3,
                 "EST": 2,
                 "IHC": 1
                 }

                 for (var i = 0; i < detailList.length; i++) {
                 if (detailList[i].length > 0) {
                 detailList[i].sort(function (a, b) {
                 if (levelPriorityDict[a.value] === levelPriorityDict[b.value]) {
                 if (codePriorityDict[a.evidenceCodeName] === codePriorityDict[b.evidenceCodeName]) return 0;
                 if (codePriorityDict[a.evidenceCodeName] < codePriorityDict[b.evidenceCodeName]) return -1;
                 if (codePriorityDict[a.evidenceCodeName] > codePriorityDict[b.evidenceCodeName]) return 1;
                 } else if (levelPriorityDict[a.value] < levelPriorityDict[b.value]) {
                 return 1;
                 } else if (levelPriorityDict[a.value] > levelPriorityDict[b.value]) {
                 return -1;
                 }
                 });
                 }
                 }
                 }

                 sortDetail(detailList);
                 */

            }
        });
    </script>
</dom-module>