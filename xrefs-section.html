<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="nextprot-elements-shared-styles.html">
<script>
  //Load JQuery if necessary
  if(typeof jQuery === "undefined"){
    (function(){
      var newscript = document.createElement('script');
      newscript.src = '../../jquery/dist/jquery.min.js';
      (document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(newscript);
    })();
  }
</script>
<script src="../nextprot/src/nextprot-core.js"></script>
<!--
`xrefs-section`
Exteranl links section present in function, medical, expression, interactions, sequence, proteomics and structures views.
@demo demo/xref-section-demo.html
-->
<dom-module id="xrefs-section">
  <template>
    <style include="nextprot-elements-shared-styles">
      :host {
        display: block;
      }
      .inline-group {
        display: inline-flex;
        margin: 2px 5px;
      }
    </style>
    <div id="xrefs-header" class="category-header">
      <h4 id="xrefs-title" class="category-title">Further external links</h4>
      <paper-spinner-lite id="spinner" active></paper-spinner-lite>
    </div>
    <div class="category-main">
      <template is="dom-repeat" items="[[_toArray(data)]]" as="category" sort="_sortCategories">
      <template is="dom-repeat" items="[[_toArray(category.value)]]" as="annotations">
      <div class="row">
        <template is="dom-if" if="[[_checkCategories()]]">
          <div class="col-xl-1 col-lg-3 col-md-12 col-sm-12 col-xs-12">
            <h4 class="annotation-category-title text-align-left"> [[annotations.name]]</h4>
          </div>
        </template>
        <div class="col-xl-11 col-lg-9 col-md-12 col-sm-12 col-xs-12">
            <template is="dom-repeat" items="[[annotations.value]]" as="annotation">
              <div class="row annotation-row">
                <div class="annotation-title-container col-lg-2 col-md-3 col-sm-3 col-xs-12">
                  <div class="annotation-title">[[annotation.name]]</div>
                </div>
                <div class="col-lg-10 col-md-9 col-sm-9 col-xs-12">
                  <template is="dom-repeat" items="[[annotation.xrefs]]" as="xref">
                    <div class="hidden-xs inline-group" role="group">
                      <template is="dom-if" if="[[xref.prefix]]">
                        <label class="btn btn-xs prefix-label">[[xref.prefix]]</label>
                      </template>
                      <a class="selectable ext-link" href="[[xref.url]]" target="_blank">[[xref.accession]]</a>
                      <template is="dom-if" if="[[xref.suffix]]">
                        <label class="suffix-label">[[xref.suffix]]</label>
                      </template>
                    </div>
                    <div class="hidden-lg hidden-md hidden-sm inline-group">
                      <div class="col-xs-12 no-padding" role="group">
                        <template is="dom-if" if="[[xref.prefix]]">
                          <label class="btn btn-xs prefix-label">[[xref.prefix]]</label>
                        </template>
                        <a class="selectable ext-link" href="[[xref.url]]" target="_blank">[[xref.accession]]</a>
                        <template is="dom-if" if="[[xref.suffix]]">
                          <label class="suffix-label">[[xref.suffix]]</label>
                        </template>
                      </div>
                    </div>
                  </template>
                </div>
                </div>
            </template>
        </div>
      </div>
      <template is="dom-if" if="[[_checkIfLast(data,index)]]">
        <hr class="bottom-line">
      </template>
      </template>
      </template>
    </div>
  </template>
  <script>
    Polymer({
      is: 'xrefs-section',
      properties: {
        nxConfig: {
          type: Object,
          value: {}
        },
        categories: {
          type: Array
        },
        count: {
          type: Number,
          notify: true
        }
      },
      ready: function(){
        var nx = new Nextprot.Client("xref-section", "ndu");
        if (this.nxConfig.env) nx.updateEnvironment(this.nxConfig.env);
        var self=this;
        nx.getAnnotationsByCategory(self.nxConfig.entry, "xref")
          .then(function (data) {
            self.getXrefByView(Object.keys(data.xrefs).map(function(k) { return data.xrefs[k] }));
            self.$.spinner.active = false;
          }).catch(function (err) {
            // catch any error that happened so far
            console.log("Argh, broken: " + err.message);
            console.log("Error at line : " + err.stack);
            self.$.spinner.active = false;
            self.count = 0;
          });
      },
      getXrefByView: function(list) {
        this.count = 0;
        data = [];
        var dataObject = {};
        var self = this;
        list.forEach(function (k) {
          if (self.categories.indexOf(k.databaseName) >= 0) {
            if (dataObject[k.databaseCategory]) dataObject[k.databaseCategory].push(k);
            else dataObject[k.databaseCategory] = [k];
          }
        });
        data = Object.keys(dataObject).map(function (key) {
          var temp = {};
          temp[key] = dataObject[key];
          return temp
        });
        data = data.map(function(t){
          t[Object.keys(t)[0]] = self._filterExceptions(t[Object.keys(t)[0]]);
          return t;
        });
        for (var i in data) {
          var cat = data[i][Object.keys(data[i])[0]];
          if (cat.length===0) data.splice(i, 1);
          cat.forEach(function(x2){self.count+=1;})
          cat.sort(function (a,b){
            var dbA = a.name.toUpperCase();
            var dbB = b.name.toUpperCase();
            var prefA = a.xrefs[0].prefix.toUpperCase();
            var prefB = b.xrefs[0].prefix.toUpperCase();
            var accA = a.xrefs[0].accession.toUpperCase();
            var accB = b.xrefs[0].accession.toUpperCase();
            if (dbA < dbB) return -1;
            else if (dbA > dbB) return 1;
            else if (prefA < prefB) return -1;
            else if (prefA > prefB) return 1;
            else if (accA < accB) return -1;
            else if (accA > accB) return 1;
            else return 0;
          })
        }
        this.data = data;
      },
      _filterExceptions: function(typeList) {
        var newTypeList = [];
        for (elem in typeList){
          if (typeList[elem].databaseName === "IntAct"
          || typeList[elem].databaseName === "BioGrid"){
            if(typeList[elem].properties.length>0){
              newTypeList.push({
                name: typeList[elem].databaseName,
                xrefs : [{
                  accession: typeList[elem].accession,
                  url : typeList[elem].resolvedUrl,
                  prefix: "",
                  suffix : typeList[elem].properties[0].name+": "+typeList[elem].properties[0].value
                }]
              })
            }
          }
          else if (typeList[elem].databaseName === "Ensembl"){
            if (typeList[elem].accession.startsWith("ENST")){
              if (typeList[elem].properties) {
                var ensembl = {
                  name: typeList[elem].databaseName,
                  xrefs : [{
                    accession: typeList[elem].accession,
                    url : typeList[elem].resolvedUrl,
                    prefix : "Transcript",
                    suffix : ""
                  }]
                };
                typeList[elem].properties.forEach(function(p){
                  if (p.name === "nxmapped protein sequence ID") {
                    var result = $.grep(typeList, function(e){ return e.accession == p.value; })[0];
                    ensembl.xrefs.push({
                      accession: result.accession,
                      url : result.resolvedUrl,
                      prefix : "Protein",
                      suffix : ""
                    });
                  }
                })
                typeList[elem].properties.forEach(function(p){
                  if (p.name === "nxmapped gene ID") {
                    var result = $.grep(typeList, function(e){ return e.accession == p.value; })[0];
                    ensembl.xrefs.push({
                      accession: result.accession,
                      url : result.resolvedUrl,
                      prefix : "Gene",
                      suffix : ""
                    });
                  }
                })
                newTypeList.push(ensembl);
              }
            }
          }
          else if (typeList[elem].databaseName === "EMBL"){ //TODO
            if (typeList[elem].properties.length > 0) {
              var molType = $.grep(typeList[elem].properties, function(e){ return e.name === "molecule type"; })[0];
              var addInfos = $.grep(typeList[elem].properties, function(e){ return e.name === "status"})[0];
              var suffix = addInfos ? status[addInfos.value] : "";
              var embl = {
                name: typeList[elem].databaseName,
                xrefs : []
              };
              if (molType.value === "mRNA") {
                embl.xrefs.push({
                  accession: typeList[elem].accession,
                  url : typeList[elem].resolvedUrl,
                  prefix : "mRNA",
                  suffix : ""
                })
                var translationID = $.grep(typeList[elem].properties, function(e){ return e.name === "protein sequence ID"; })[0].value;
                var translation = $.grep(typeList, function(e){ return e.accession == translationID; })[0];
                embl.xrefs.push({
                  accession: translation.accession,
                  url : translation.resolvedUrl,
                  prefix : "Translation",
                  suffix : suffix
                })
              }
              else if (molType.value === "protein") {
                var geneIDs = $.grep(typeList[elem].properties, function(e){ return e.name === "genomic sequence ID"; });
                geneIDs.forEach(function(g){
                  var gene = $.grep(typeList, function(e){ return e.accession == g.value; })[0];
                  embl.xrefs.push({
                    accession: gene.accession,
                    url : gene.resolvedUrl,
                    prefix : "Genomic DNA",
                    suffix : ""
                  })
                })
                embl.xrefs.push({
                  accession: typeList[elem].accession,
                  url : typeList[elem].resolvedUrl,
                  prefix : "Translation",
                  suffix : suffix
                })
              }
              else if (molType.value === "Genomic_DNA" && addInfos.value) {
                var geneIDs = $.grep(typeList[elem].properties, function(e){ return e.name === "genomic sequence ID"; });
                embl.xrefs.push({
                  accession: typeList[elem].accession,
                  url : typeList[elem].resolvedUrl,
                  prefix : "Genomic DNA",
                  suffix : suffix
                })
              }
              newTypeList.push(embl);
            }
          }
          else if (typeList[elem].databaseName === "RefSeq"){ //TODO
            if (typeList[elem].properties.length > 0) {
              var nucleotideID = $.grep(typeList[elem].properties, function(e){ return e.name === "nucleotide sequence ID"; })[0].value;
              var refseq = {
                name: typeList[elem].databaseName,
                xrefs : [{
                  accession: typeList[elem].accession,
                  url : typeList[elem].resolvedUrl,
                  prefix : "Protein",
                  suffix : ""
                }]
              };
              var nucleotide = $.grep(typeList, function(e){ return e.accession == nucleotideID; })[0];
              refseq.xrefs.push({
                accession: nucleotide.accession,
                url : nucleotide.resolvedUrl,
                prefix : "Nucleotide sequence",
                suffix : ""
              });
              newTypeList.push(refseq);
            }
          }
          else if (typeList[elem].databaseName === "Reactome"
            || typeList[elem].databaseName === "KEGGPathway") {
            continue;
          }
          else {
            var suffix = "";
            if (typeList[elem].properties.length>0){
              var addInfos = $.grep(typeList[elem].properties, function(e){ return e.name === "entry name" || e.name === "isoform ID" || e.name === "gene designation" || e.name === "taxonomic scope"; })[0];
              suffix = addInfos ? addInfos.value : "";
            }
            newTypeList.push({
              name: typeList[elem].databaseName,
              xrefs : [{
                accession: typeList[elem].accession,
                url : typeList[elem].resolvedUrl,
                prefix : "",
                suffix : suffix
              }]
            })
          }

        }
        return newTypeList;
      },
      _sortCategories: function(a,b){
        var firstCategoryName = Object.keys(a.value)[0];
        var secondCategoryName = Object.keys(b.value)[0];
        if (firstCategoryName.toLowerCase() == "other" &&
            secondCategoryName.toLowerCase() != "other") return 1;
        if (secondCategoryName.toLowerCase() == "other" &&
                firstCategoryName.toLowerCase() != "other") return -1;
        return firstCategoryName.toLowerCase() > secondCategoryName.toLowerCase() ? 1 : -1;
      },
      _toArray: function(obj) {
        if (typeof obj === 'object') {
          return Object.keys(obj).map(function(key) {
            return {
              name: key,
              value: obj[key]
            };
          });
        }
        return null;
      },
      _checkIfLast: function(array,index){
        if(array.length-1===index) return true;
        return false;
      },
      _checkCategories: function(){
        if(this.data.length>1 || Object.keys(this.data[0])[0].toLowerCase()!="other") return true;
        return false;
      }
    });
  </script>
</dom-module>
